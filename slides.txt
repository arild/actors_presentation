<div class="slides">
    <section>
	<h1>Concurrency abstractions in Scala</h1>
	<p>https://github.com/arild/actors_presentation.git</p>
        <p>Arild Nilsen<br>Sjur Millidahl</p>
	<br>
	<p>October, 2012</p>
    </section>

    <section>
        <h2>Motivatation</h2>
        <ul>
            <li class="fragment">With the advent of multi-core processors concurrent programming is becoming indispensable</li>
        </ul>
    </section>

    <section>
        <h2>Shared Memory</h2>
        <ul>
        <li class="fragment">Communicate by altering shared memory</li>
        <li class="fragment">Unpredictable results if unguarded (race conditions)</li>
        <li class="fragment">Difficult to get correct and to reason about</li>
        <li class="fragment">Might be difficult to scale (lock contention)</li>
        <li class="fragment">Deadlocks</li>
        </ul>
    </section>

    <section>
        <h2>Actors</h2>
        <ul>
        <li class="fragment">Lightweight processes</li>
        <li class="fragment">Isolated from other processes</li>
        <li class="fragment">No shared state</li>
        <li class="fragment">Inherently concurrent</li>
        <li class="fragment">Communicate using asynchronous messages</li>
        <li class="fragment">Messages buffered in an inbox</li>
        <li class="fragment">Tends to be easier to reason about</li>
        </ul>
    </section>

    <section>
        <h2>Akkar</h2>
	<ul>
	    <li class="fragment">"Todarodes sagittatus" has 10 tentacles and likes to swim with other Akkars</li>
	    <li class="fragment">An Akkar has a highly complex nervous system, only part of which is localized in its brain</li>
	    <li class="fragment">Two-thirds of an octopus's neurons are found in the nerve cords of its arms, which have limited functional autonomy</li>
	    <li class="fragment">Octopus arms show a variety of complex reflex actions that persist even when they have no input from the brain</li>
	</ul>
    </section>

    <section>
        <h2>Example Actor</h2>
        <div class="fragment"><p><pre><code>
import scala.actors.Actor
class myActor extends Actor {
  def act(){
    receive {
      case s: String => sender ! response
  }
}</code></pre></p></div>
<div class="fragment"><p><code><pre>
val actor = new MyActor
actor.start
actor ! "hello"</pre></code></p></div>
    </section>

    <section>
        <h2>Messages</h2>
        <ul>
            <li class="fragment">! send async</li>
            <li class="fragment">!? sends synchronously (wait for result)</li>
            <li class="fragment">!! send and receive future</li>
        </ul>
    </section>

    <section>
        <h2>specs2</h2>
        <ul>
            <li class="fragment">used in our code examples</li>
            <li class="fragment">"prose-driven-test" lib</li>
        </ul>
        <div class="fragment"><p><pre><code>
"ComputeActor" should {
  "compute length of string" in {
    val result = ...
    result must beEqualTo(5)
  }
} 
</code></pre></p></div>
    </section>

    <section>
        <h2>Do exersices</h2>
        <ul>
        <li class="fragment">git clone https://github.com/arild/actors_presentation.git</li>
        <li class="fragment">git checkout actors</li>
        <li class="fragment">Complete predefined tests for Actor and implementation of Actor</li>
        <li class="fragment">git checkout actors-solved</li>
        </ul>
    </section>

    <section>
        <h2>Futures</h2>
        <ul>
        <li class="fragment">SIP-14 - redesign of scala.concurrent</li>
        <li class="fragment">Placeholder object for a result that doesnâ€™t yet exist</li>
        </ul>
    </section>

    <section>
        <h2>SIP-14 definition</h2>
        <ul>
        <li class="fragment">A Future is a head-handle to a single value (read-many) that may be available within a specific time-frame</li>
        <li class="fragment">A Promise is a write-handle to a single value (write-once) that should be made available within a specific time-frame</li>
        <li class="fragment">http://skillsmatter.com/podcast/scala/the-future-i-was-promised</li>
        </ul>
    </section>

    <section>
        <h2>Future monadic Operations</h2>
        <ul>
        <li class="fragment"><code>def foreach[U](f: T => U): Unit</code></li>
        <li class="fragment"><code>def map[S](f: T => S): Future[S]</code></li>
        <li class="fragment"><code>def flatMap[S](f: T => Future[S]): Future[S]</code></li>
        <li class="fragment"><code>def filter(p: T => Boolean): Future[T]</code></li>
        </ul>
    </section>

    <section>
        <h2>Future code example</h2>
        <div class="fragment"><p><code><pre>
println("Test print before future")
val s = "hello"
val f = future {
  Thread.sleep(10)
  s + " future!"
}
println("Test print after future")
f onSucess { case s => println(s) } //Completely asynchronous
Await.ready(f, Duration.Inf) //Blocks until the future is ready
</pre></code></p></div>
       <div class="fragment"><p>Output: <br /><pre><code>Test print before future
Test print after future
hello world!
</code></pre></p></div>
    </section>

    <section>
        <h2>Promise code example</h2>
        <p  class="fragment"><code><pre>
val f = future {
  new SumSequence(0, 1).perform
}
val p = promise[Int]()
p completeWith f
p.f onSuccess { case s => println("Result " + s) }
</pre></code></p>
    </section>

    <section>
        <h2>Do exersices</h2>
        <ul>
        <li class="fragment">git checkout futures</li>
        <li class="fragment">Complete predefined tests for Futures and implementation of Future</li>
        <li class="fragment">git checkout futures-solved</li>
        </ul>
    </section>
</div>			
