*Concurrency abstractions in Scala
- https://github.com/arild/actors_presentation.git

*Motivatation
- With the advent of multi-core processors concurrent programming is becoming indispensable

*Shared Memory
- Communicate by altering shared memory
- Unpredictable results if unguarded (race conditions)
- Difficult to get correct and to reason about
- Might be difficult to scale (lock contention)
- Deadlocks

*Actors
- Lightweight processes
- Isolated from other processes
- No shared state
- Inherently concurrent
- Communicate using asynchronous messages
- Messages buffered in an inbox
- Tends to be easier to reason about

*Akkar - Actors in the real world

*Example Actor
- slide1
import scala.actors.Actor
class myActor extends Actor {
  def act(){
    receive {
      case s: String => sender ! response
  }
}

val actor = new MyActor
actor.start
actor ! "hello"

- slide2
- ! send async
- !? sends synchronously (wait for result)
- !! send and receive future
val actor = new ComputeActor
actor.start
val result = actor !! msg
println("result is " + result())

* specs2
- used in our code examples
- "prose-driven-test" lib

"ComputeActor" should {
  "compute length of string" in {
    val result = ...
    result must beEqualTo(5)
  }
} 

* Do exersices
- git clone https://github.com/arild/actors_presentation.git
- git checkout actors
- Complete predefined tests for Actor and implementation of Actor
- git checkout actors-solved

* Futures
- SIP-14 - redesign of scala.concurrent
- Placeholder object for a result that doesnâ€™t yet exist

* SIP-14 definition
- A Future is a head-handle to a single value (read-many) that may be available within a specific time-frame
- A Promise is a write-handle to a single value (write-once) that should be made available within a specific time-frame
- http://skillsmatter.com/podcast/scala/the-future-i-was-promised

* Future monadic Operations
def foreach[U](f: T => U): Unit
def map[S](f: T => S): Future[S]
def flatMap[S](f: T => Future[S]): Future[S]
def filter(p: T => Boolean): Future[T]

* Future code example
#codebox
println("Test print before future")
val s = "hello"
val f = future {
  Thread.sleep(10)
  s + " future!"
}
println("Test print after future")
f onSucess { case s => println(s) } //Completely asynchronous
Await.ready(f, Duration.Inf) //Blocks until the future is ready

#output
Test print before future
Test print after future
hello world!

* Promise code example
#codebox
val f = future {
  new SumSequence(0, 1).perform
}
val p = promise[Int]()
p completeWith f
p.f onSuccess { case s => println("Result " + s) }

* Do Exersice
- git branch futures
- Complete predefined tests for Futures and implementation of Future
- git checkout actors-solved



